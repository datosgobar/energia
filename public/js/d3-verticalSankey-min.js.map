{"version":3,"sources":["../src/js/d3-verticalSankey.js"],"names":["d3","sankey","computeNodeLinks","nodes","forEach","node","sourceLinks","targetLinks","links","link","source","target","push","computeNodeValues","value","Math","max","sum","computeNodeBreadths","iterations","relaxLeftToRight","alpha","weightedSource","nodesByBreadth","breadth","length","y","x","relaxRightToLeft","weightedTarget","slice","reverse","resolveCollisions","dy","x0","n","i","sort","ascendingDepth","nodePadding","size","a","b","nest","key","d","sortKeys","ascending","entries","map","values","ky","moveSinksDown","scaleNodeBreadths","kx","computeNodeDepths","remainingNodes","nextNodes","indexOf","nodeWidth","computeLinkDepths","ascendingSourceDepth","ascendingTargetDepth","sy","ty","center","_","arguments","layout","relayout","x1","y0","y1","yi","interpolateNumber","curvature"],"mappings":"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","file":"d3-verticalSankey-min.js","sourcesContent":["d3.sankey = function() {\n  var sankey = {},\n      nodeWidth = 24,\n      nodePadding = 8, // was 8, needs to be much bigger. these numbers are actually overwritten in the html when we instantiate the viz!\n      size = [1, 1],\n      nodes = [],\n      links = [];\n  sankey.nodeWidth = function(_) {\n    if (!arguments.length) return nodeWidth;\n    nodeWidth = +_;\n    return sankey;\n  };\n  sankey.nodePadding = function(_) {\n    if (!arguments.length) return nodePadding;\n    nodePadding = +_;\n    return sankey;\n  };\n  sankey.nodes = function(_) {\n    if (!arguments.length) return nodes;\n    nodes = _;\n    return sankey;\n  };\n  sankey.links = function(_) {\n    if (!arguments.length) return links;\n    links = _;\n    return sankey;\n  };\n  sankey.size = function(_) {\n    if (!arguments.length) return size;\n    size = _;\n    return sankey;\n  };\n  sankey.layout = function(iterations) {\n    computeNodeLinks();\n    computeNodeValues();\n\n    // big changes here\n    // change the order and depths (y pos) won't need iterations\n    computeNodeDepths();\n    computeNodeBreadths(iterations);\n\n    computeLinkDepths();\n    return sankey;\n  };\n  sankey.relayout = function() {\n    computeLinkDepths();\n    return sankey;\n  };\n  sankey.link = function() {\n    var curvature = .5;\n\n      // x0 = line start X\n      // y0 = line start Y\n\n      // x1 = line end X\n      // y1 = line end Y\n\n      // y2 = control point 1 (Y pos)\n      // y3 = control point 2 (Y pos)\n\n    function link(d) {\n\n        // big changes here obviously, more comments to follow\n        var x0 = d.source.x + d.sy + d.dy / 2,\n            x1 = d.target.x + d.ty + d.dy / 2,\n          y0 = d.source.y + nodeWidth,\n          y1 = d.target.y,\n          yi = d3.interpolateNumber(y0, y1),\n          y2 = yi(curvature),\n          y3 = yi(1 - curvature);\n\n        // ToDo - nice to have - allow flow up or down! Plenty of use cases for starting at the bottom,\n        // but main one is trickle down (economics, budgets etc), not up\n\n      return \"M\" + x0 + \",\" + y0        // start (of SVG path)\n           + \"C\" + x0 + \",\" + y2      // CP1 (curve control point)\n           + \" \" + x1 + \",\" + y3      // CP2\n           + \" \" + x1 + \",\" + y1;       // end\n    }\n\n    link.curvature = function(_) {\n      if (!arguments.length) return curvature;\n      curvature = +_;\n      return link;\n    };\n\n    return link;\n  };\n\n  // Populate the sourceLinks and targetLinks for each node.\n  // Also, if the source and target are not objects, assume they are indices.\n  function computeNodeLinks() {\n    nodes.forEach(function(node) {\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    });\n    links.forEach(function(link) {\n      var source = link.source,\n          target = link.target;\n      if (typeof source === \"number\") source = link.source = nodes[link.source];\n      if (typeof target === \"number\") target = link.target = nodes[link.target];\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    });\n  }\n\n  // Compute the value (size) of each node by summing the associated links.\n  function computeNodeValues() {\n    nodes.forEach(function(node) {\n      node.value = Math.max(\n        d3.sum(node.sourceLinks, value),\n        d3.sum(node.targetLinks, value)\n      );\n    });\n  }\n\n  // take a grouping of the nodes - the vertical columns\n  // there shouldnt be 8 - there will be more, the total number of 1st level sources\n  // then iterate over them and give them an incrementing x\n  // because the data structure is ALL nodes, just flattened, don't just apply at the top level\n  // then everything should have an X\n  // THEN, for the Y\n  // do the same thing, this time on the grouping of 8! i.e. 8 different Y values, not loads of different ones!\n  function computeNodeBreadths(iterations) {\n          var nodesByBreadth = d3.nest()\n        .key(function(d) { return d.y; })\n        .sortKeys(d3.ascending)\n        .entries(nodes)\n        .map(function(d) { return d.values; }); // values! we are using the values also as a way to seperate nodes (not just stroke width)?\n\n      // this bit is actually the node sizes (widths)\n      //var ky = (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value)\n      // this should be only source nodes surely (level 1)\n      var ky = (size[0] - (nodesByBreadth[0].length - 1) * nodePadding) / d3.sum(nodesByBreadth[0], value);\n      // I'd like them to be much bigger, this calc doesn't seem to fill the space!?\n\n      nodesByBreadth.forEach(function(nodes) {\n        nodes.forEach(function(node, i) {\n          node.x = i;\n          node.dy = node.value * ky;\n        });\n      });\n\n      links.forEach(function(link) {\n          link.dy = link.value * ky;\n      });\n\n      resolveCollisions();\n\n      for (var alpha = 1; iterations > 0; --iterations) {\n        relaxLeftToRight(alpha);\n        resolveCollisions();\n\n        relaxRightToLeft(alpha *= .99);\n        resolveCollisions();\n      }\n\n      // these relax methods should probably be operating on one level of the nodes, not all!?\n\n      function relaxLeftToRight(alpha) {\n        nodesByBreadth.forEach(function(nodes, breadth) {\n            nodes.forEach(function(node) {\n                if (node.targetLinks.length) {\n                    var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);\n                    node.x += (y - center(node)) * alpha;\n                }\n            });\n        });\n\n      function weightedSource(link) {\n        return center(link.source) * link.value;\n      }\n    }\n\n    function relaxRightToLeft(alpha) {\n      nodesByBreadth.slice().reverse().forEach(function(nodes) {\n        nodes.forEach(function(node) {\n          if (node.sourceLinks.length) {\n            var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);\n            node.x += (y - center(node)) * alpha;\n          }\n        });\n      });\n\n      function weightedTarget(link) {\n        return center(link.target) * link.value;\n      }\n    }\n\n      function resolveCollisions() {\n        nodesByBreadth.forEach(function(nodes) {\n            var node,\n              dy,\n              x0 = 0,\n              n = nodes.length,\n              i;\n\n            // Push any overlapping nodes right.\n            nodes.sort(ascendingDepth);\n            for (i = 0; i < n; ++i) {\n                node = nodes[i];\n                dy = x0 - node.x;\n                if (dy > 0) node.x += dy;\n                x0 = node.x + node.dy + nodePadding;\n            }\n\n            // If the rightmost node goes outside the bounds, push it left.\n            dy = x0 - nodePadding - size[0]; // was size[1]\n            if (dy > 0) {\n                x0 = node.x -= dy;\n\n                // Push any overlapping nodes left.\n                for (i = n - 2; i >= 0; --i) {\n                    node = nodes[i];\n                    dy = node.x + node.dy + nodePadding - x0; // was y0\n                    if (dy > 0) node.x -= dy;\n                        x0 = node.x;\n                    }\n                }\n            });\n        }\n\n      function ascendingDepth(a, b) {\n          return a.x - b.x; // left sort\n          // return b.x - a.x; // right sort\n      }\n    }\n\n  // this moves all end points (sinks!) to the most extreme bottom\n  function moveSinksDown(y) {\n    nodes.forEach(function(node) {\n      if (!node.sourceLinks.length) {\n        node.y = y - 1;\n      }\n    });\n  }\n\n  // shift their locations out to occupy the screen\n  function scaleNodeBreadths(kx) {\n    nodes.forEach(function(node) {\n      node.y *= kx;\n    });\n  }\n\n  function computeNodeDepths() {\n        var remainingNodes = nodes,\n        nextNodes,\n        y = 0;\n\n        while (remainingNodes.length) {\n          nextNodes = [];\n          remainingNodes.forEach(function(node) {\n            node.y = y;\n            //node.dx = nodeWidth;\n            node.sourceLinks.forEach(function(link) {\n              if (nextNodes.indexOf(link.target) < 0) {\n                nextNodes.push(link.target);\n              }\n            });\n          });\n          remainingNodes = nextNodes;\n          ++y;\n        }\n\n        // move end points to the very bottom\n        moveSinksDown(y);\n\n        scaleNodeBreadths((size[1] - nodeWidth) / (y - 1));\n    }\n\n  // .ty is the offset in terms of node position of the link (target)\n  function computeLinkDepths() {\n    nodes.forEach(function(node) {\n      node.sourceLinks.sort(ascendingTargetDepth);\n      node.targetLinks.sort(ascendingSourceDepth);\n    });\n    nodes.forEach(function(node) {\n      var sy = 0, ty = 0;\n          //ty = node.dy;\n      node.sourceLinks.forEach(function(link) {\n        link.sy = sy;\n        sy += link.dy;\n      });\n      node.targetLinks.forEach(function(link) {\n          // this is simply saying, for each target, keep adding the width of the link\n          // so what if it was the other way round. start with full width then subtract?\n        link.ty = ty;\n        ty += link.dy;\n        //ty -= link.dy;\n      });\n    });\n\n    function ascendingSourceDepth(a, b) {\n      // return a.source.y - b.source.y;\n      return a.source.x - b.source.x;\n    }\n\n    function ascendingTargetDepth(a, b) {\n      //return a.target.y - b.target.y;\n        return a.target.x - b.target.x;\n    }\n  }\n\n  function center(node) {\n    return 0; // AlteraciÃ³n del codigo\n    // return node.y + node.dy / 2;\n  }\n\n  function value(link) {\n    return link.value;\n  }\n\n  return sankey;\n};\n"]}